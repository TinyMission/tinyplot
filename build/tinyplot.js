// Generated by CoffeeScript 1.6.3
(function() {
  var Axis, ONE_DAY, ONE_HOUR, ONE_MINUTE,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.NumberFormatter = (function() {
    function NumberFormatter() {}

    NumberFormatter.prototype.format = function(span, value) {
      return value.toString();
    };

    return NumberFormatter;

  })();

  this.DollarFormatter = (function() {
    function DollarFormatter() {}

    DollarFormatter.prototype.format = function(span, value) {
      var s;
      s = value.toFixed(2);
      if (s.endsWith('00')) {
        return value.toString();
      } else {
        return s;
      }
    };

    return DollarFormatter;

  })();

  this.TimeFormatter = (function() {
    function TimeFormatter() {}

    TimeFormatter.prototype.format = function(span, value) {
      var formatString, t;
      t = moment(value);
      formatString = span < 10000 ? 'mm:ss.SS' : span < 3600 * 1000 ? 'hh:mm:ss' : span < 3600 * 1000 * 24 * 30 ? 'MM/DD|hh:mm A' : 'YYYY-MM-DD';
      return t.format(formatString);
    };

    return TimeFormatter;

  })();

  ONE_MINUTE = 60000;

  ONE_HOUR = ONE_MINUTE * 60;

  ONE_DAY = ONE_HOUR * 24;

  Axis = (function() {
    function Axis(min, max) {
      this.dirty = true;
      this.step = 1;
      this.clampMax = null;
      this.clampMin = null;
      this.tickSize = 8;
      this.fontSize = 12;
      this.color = '#444';
      this.gridColor = '#ccc';
      this.maxTicks = 10;
      this.label = null;
      this.roundingStrategy = 'base10';
      this.resize(min, max);
    }

    Axis.prototype.toString = function() {
      return "" + this.min + " to " + this.max + ", step = " + this.step + " (clamp at " + this.clampMin + " to " + this.clampMax + ")";
    };

    Axis.prototype.makeDirty = function() {
      return this.dirty = true;
    };

    Axis.prototype.resize = function(min, max) {
      var exp, _results;
      this.min = min;
      this.max = max;
      this.span = max - min;
      switch (this.roundingStrategy) {
        case 'base10':
          exp = Math.floor(Math.log10(this.span) - 1);
          this.step = Math.pow(10, exp);
          break;
        case 'time':
          if (this.span < 1000) {
            this.step = 100;
          } else if (this.span < ONE_MINUTE) {
            this.step = 1000;
          } else if (this.span < ONE_HOUR) {
            this.step = ONE_MINUTE;
          } else if (this.span < ONE_DAY * 3) {
            this.step = ONE_HOUR;
          } else {
            this.step = ONE_DAY;
          }
          break;
        default:
          throw "Invalid roundingStrategy: " + this.roundingStrategy;
      }
      _results = [];
      while (this.span / this.step > this.maxTicks) {
        _results.push(this.step *= 2);
      }
      return _results;
    };

    Axis.prototype.zoom = function(factor) {
      var avg, max, min, newSpan;
      avg = (this.max + this.min) / 2;
      newSpan = this.span / factor;
      if (this.clampMin && this.clampMax && newSpan > (this.clampMax - this.clampMin)) {
        this.min = this.clampMin;
        this.max = this.clampMax;
        this.span = this.clampMax - this.clampMin;
      } else {
        min = avg - newSpan / 2;
        max = avg + newSpan / 2;
        this.resize(min, max);
      }
      return this.dirty = true;
    };

    Axis.prototype.pan = function(delta) {
      if (delta < 0) {
        if (!this.clampMax || this.clampMax > this.max) {
          this.max = Math.min(this.clampMax, this.max - delta);
          this.min = this.max - this.span;
        }
      } else {
        if (!this.clampMin || this.clampMin < this.min) {
          this.min = Math.max(this.clampMin, this.min - delta);
          this.max = this.min + this.span;
        }
      }
      return this.dirty = true;
    };

    Axis.prototype.round = function() {
      return this.resize(Math.floor(this.min / this.step) * this.step, Math.ceil(this.max / this.step) * this.step);
    };

    Axis.prototype.clamp = function() {
      this.clampMin = this.min;
      return this.clampMax = this.max;
    };

    Axis.prototype.render = function(canvas, formatter, width, height) {
      canvas.clearRect(0, 0, width, height);
      return this.dirty = false;
    };

    Axis.prototype.renderGrid = function(canvas, width, height) {
      return {};
    };

    return Axis;

  })();

  this.XAxis = (function(_super) {
    __extends(XAxis, _super);

    function XAxis(canvas, min, max) {
      XAxis.__super__.constructor.call(this, canvas, min, max);
      this.labels = null;
    }

    XAxis.prototype.setFixedArray = function(labels) {
      this.labels = labels;
      this.min = -0.5;
      this.max = this.labels.length - 0.5;
      this.step = 1;
      return this.span = this.labels.length;
    };

    XAxis.prototype.render = function(canvas, formatter, width, height) {
      var i, line, lines, scale, text, x, xActual, yActual, _i, _len;
      XAxis.__super__.render.call(this, canvas, formatter, width, height);
      scale = width / this.span;
      x = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        canvas.moveTo(xActual, 0);
        canvas.lineTo(xActual, this.tickSize);
        x += this.step;
      }
      canvas.stroke();
      x = Math.floor(this.min / this.step) * this.step;
      canvas.font = "" + this.fontSize + "px sans-serif";
      canvas.textAlign = 'center';
      canvas.fillStyle = this.color;
      i = -1;
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        text = this.labels ? i > -1 ? this.labels[i] : '' : formatter.format(this.span, x);
        lines = text.split('|');
        yActual = this.tickSize + this.fontSize;
        i += 1;
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          canvas.fillText(line, xActual, yActual);
          yActual += this.fontSize;
        }
        x += this.step;
      }
      return canvas.fillText(this.label, width / 2, this.tickSize + 3 * this.fontSize + 2);
    };

    XAxis.prototype.renderGrid = function(canvas, width, height) {
      var scale, x, xActual;
      scale = width / this.span;
      x = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.gridColor;
      canvas.beginPath();
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        canvas.moveTo(xActual, 0);
        canvas.lineTo(xActual, height);
        x += this.step;
      }
      return canvas.stroke();
    };

    return XAxis;

  })(Axis);

  this.YAxis = (function(_super) {
    __extends(YAxis, _super);

    function YAxis(canvas, min, max) {
      YAxis.__super__.constructor.call(this, canvas, min, max);
    }

    YAxis.prototype.render = function(canvas, formatter, width, height) {
      var line, lines, scale, text, y, yActual, _i, _len;
      YAxis.__super__.render.call(this, canvas, formatter, width, height);
      scale = height / this.span;
      y = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        if (yActual < 0) {
          yActual = 0.5;
        }
        canvas.moveTo(width - this.tickSize, yActual);
        canvas.lineTo(width, yActual);
        y += this.step;
      }
      canvas.stroke();
      y = Math.floor(this.min / this.step) * this.step;
      canvas.font = "" + this.fontSize + "px sans-serif";
      canvas.textAlign = 'right';
      canvas.fillStyle = this.color;
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        canvas.textBaseline = yActual <= 0 ? 'top' : yActual >= height - 1 ? 'alphabetic' : 'middle';
        text = formatter.format(this.span, y);
        lines = text.split('|');
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          canvas.fillText(line, width - this.tickSize - 3, yActual);
          yActual += this.fontSize;
        }
        y += this.step;
      }
      canvas.textAlign = 'center';
      canvas.translate(this.fontSize, height / 2);
      canvas.rotate(3 * Math.PI / 2);
      return canvas.fillText(this.label, 0, 0);
    };

    YAxis.prototype.renderGrid = function(canvas, width, height) {
      var scale, y, yActual;
      scale = height / this.span;
      y = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.gridColor;
      canvas.beginPath();
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        canvas.moveTo(0, yActual);
        canvas.lineTo(width, yActual);
        y += this.step;
      }
      return canvas.stroke();
    };

    return YAxis;

  })(Axis);

}).call(this);

/*
//@ sourceMappingURL=axes.map
*/
;// Generated by CoffeeScript 1.6.3
(function() {
  var RenderContext, initCanvas,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.tinyplot = {};

  RenderContext = (function() {
    function RenderContext(canvas, width, height, xRange, yRange) {
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this.xRange = xRange;
      this.yRange = yRange;
      this.lineTo = __bind(this.lineTo, this);
      this.moveTo = __bind(this.moveTo, this);
      ({});
    }

    RenderContext.prototype.clear = function() {
      return this.canvas.clearRect(0, 0, this.width, this.height);
    };

    RenderContext.prototype.setStroke = function(style, width) {
      this.canvas.strokeStyle = style;
      return this.canvas.lineWidth = width;
    };

    RenderContext.prototype.stroke = function(cb) {
      this.canvas.beginPath();
      cb();
      return this.canvas.stroke();
    };

    RenderContext.prototype.plotToCanvas = function(p) {
      p.x = (p.x - this.xRange.min) / this.xRange.span * this.width;
      return p.y = (1 - (p.y - this.yRange.min) / this.yRange.span) * this.height;
    };

    RenderContext.prototype.canvasToPlot = function(p) {
      p.x = p.x * this.xRange.span / this.width + this.xRange.min;
      return p.y = (1 - p.y / this.height) * this.yRange.span + this.yRange.min;
    };

    RenderContext.prototype.moveTo = function(p) {
      this.plotToCanvas(p);
      return this.canvas.moveTo(p.x, p.y);
    };

    RenderContext.prototype.lineTo = function(p) {
      this.plotToCanvas(p);
      return this.canvas.lineTo(p.x, p.y);
    };

    RenderContext.prototype.drawMarkers = function(marker, size, color, xs, ys) {
      var i, p, _i, _ref, _results;
      this.canvas.fillStyle = color;
      _results = [];
      for (i = _i = 0, _ref = xs.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        p = {
          x: xs[i],
          y: ys[i]
        };
        this.plotToCanvas(p);
        switch (marker) {
          case 'circle':
            this.canvas.beginPath();
            this.canvas.arc(p.x, p.y, size / 2, 0, Math.PI * 2, false);
            _results.push(this.canvas.fill());
            break;
          case 'triangle':
            this.canvas.beginPath();
            this.canvas.moveTo(p.x, p.y - size / 2);
            this.canvas.lineTo(p.x - size / 2, p.y + size / 2);
            this.canvas.lineTo(p.x + size / 2, p.y + size / 2);
            _results.push(this.canvas.fill());
            break;
          case 'square':
            this.canvas.beginPath();
            this.canvas.moveTo(p.x - size / 2, p.y - size / 2);
            this.canvas.lineTo(p.x - size / 2, p.y + size / 2);
            this.canvas.lineTo(p.x + size / 2, p.y + size / 2);
            this.canvas.lineTo(p.x + size / 2, p.y - size / 2);
            _results.push(this.canvas.fill());
            break;
          default:
            throw "Unknown marker: " + marker;
        }
      }
      return _results;
    };

    return RenderContext;

  })();

  initCanvas = function(container) {
    var canvasElem;
    canvasElem = container.find('canvas')[0];
    canvasElem.width = container.width();
    canvasElem.height = container.height();
    return canvasElem.getContext('2d');
  };

  this.Chart = (function() {
    function Chart(container, opts) {
      var startClick,
        _this = this;
      this.container = $(container);
      this.container.addClass('tinyplot-chart');
      this.opts = opts;
      _.defaults(opts, {
        title: 'Chart Title',
        subtitle: '',
        xZoom: 'none',
        yZoom: 'none',
        xLabel: 'x',
        yLabel: 'y',
        xMaxTicks: 10,
        yMaxTicks: 10,
        grid: null,
        useDataCanvas: true,
        interact: true
      });
      this.xZoomType = opts.xZoom;
      this.yZoomType = opts.yZoom;
      this.xFormatter = new NumberFormatter();
      this.yFormatter = new NumberFormatter();
      this.titleArea = $('<div class="title-area"></div>').appendTo(this.container);
      $("<div class='title text'>" + opts.title + "</div>").appendTo(this.titleArea);
      $("<div class='subtitle text'>" + opts.subtitle + "</div>").appendTo(this.titleArea);
      this.xAxisCanvasContainer = $('<div class="x-axis"><canvas/></div>').appendTo(this.container);
      this.xAxisCanvas = initCanvas(this.xAxisCanvasContainer);
      this.xAxis = new XAxis(0, 1);
      this.xAxis.label = this.opts.xLabel;
      this.xAxis.maxTicks = this.opts.xMaxTicks;
      this.yAxisCanvasContainer = $('<div class="y-axis"><canvas/></div>').appendTo(this.container);
      this.yAxisCanvas = initCanvas(this.yAxisCanvasContainer);
      this.yAxis = new YAxis(0, 1);
      this.yAxis.label = this.opts.yLabel;
      this.yAxis.maxTicks = this.opts.yMaxTicks;
      this.dataCanvasContainer = $('<div class="data"></div>').appendTo(this.container);
      if (this.opts.useDataCanvas) {
        this.dataCanvasContainer.append('<canvas/>');
        this.dataCanvas = initCanvas(this.dataCanvasContainer);
        this.makeContext();
      } else {
        this.dataCanvas = null;
        this.dataCanvasContainer.addClass('no-canvas');
        this.context = null;
      }
      if (this.opts.interact) {
        this.dataIntercept = $('<div class="data-intercept"></div>').appendTo(this.container);
        startClick = false;
        this.dataIntercept.mousedown(function(evt) {
          return startClick = true;
        });
        this.dataIntercept.click(function(evt) {
          if (startClick) {
            _this.onClick({
              x: evt.offsetX,
              y: evt.offsetY
            });
            return startClick = false;
          }
        });
        interact(this.dataIntercept[0]).draggable({
          inertia: true,
          onstart: function(evt) {
            return startClick = false;
          },
          onmove: function(evt) {
            return _this.pan(evt.dx, evt.dy);
          }
        }).gesturable({
          onmove: function(evt) {
            return _this.zoom(1 + evt.ds);
          }
        });
        this.container.on('mousewheel', function(evt) {
          _this.zoom(1 + evt.deltaY / 1000);
          return evt.preventDefault();
        });
      }
    }

    Chart.prototype.xResize = function(min, max) {
      this.xAxis.resize(min, max);
      console.log("xAxis: " + (this.xAxis.toString()));
      return this.xAxis.makeDirty();
    };

    Chart.prototype.xRound = function() {
      this.xAxis.round();
      return console.log("xAxis: " + (this.xAxis.toString()));
    };

    Chart.prototype.xClamp = function() {
      return this.xAxis.clamp();
    };

    Chart.prototype.yResize = function(min, max) {
      this.yAxis.resize(min, max);
      console.log("yAxis: " + (this.yAxis.toString()));
      return this.yAxis.makeDirty();
    };

    Chart.prototype.yRound = function() {
      this.yAxis.round();
      return console.log("yAxis: " + (this.yAxis.toString()));
    };

    Chart.prototype.yClamp = function() {
      return this.yAxis.clamp();
    };

    Chart.prototype.makeContext = function() {
      return this.context = new RenderContext(this.dataCanvas, this.dataCanvasContainer.width(), this.dataCanvasContainer.height(), this.xAxis, this.yAxis);
    };

    Chart.prototype.zoom = function(delta) {
      var hasZoomed;
      hasZoomed = false;
      if (this.xZoomType === 'user') {
        this.xAxis.zoom(delta);
        hasZoomed = true;
      }
      if (this.yZoomType === 'user') {
        this.yAxis.zoom(delta);
        hasZoomed = true;
      }
      if (hasZoomed) {
        return this.render();
      }
    };

    Chart.prototype.pan = function(dx, dy) {
      var hasPanned;
      hasPanned = false;
      if (this.xZoomType === 'user') {
        this.xAxis.pan(dx / this.context.width * this.xAxis.span);
        hasPanned = true;
      }
      if (this.yZoomType === 'user') {
        this.yAxis.pan(dy / this.context.height * this.yAxis.span);
        hasPanned = true;
      }
      if (hasPanned) {
        return this.render();
      }
    };

    Chart.prototype.onClick = function(p) {
      return {};
    };

    Chart.prototype.renderData = function(context) {
      return {};
    };

    Chart.prototype.render = function() {
      var startTime, stopTime;
      startTime = new Date().getTime();
      if (this.xAxis.dirty) {
        this.xAxis.render(this.xAxisCanvas, this.xFormatter, this.xAxisCanvasContainer.width(), this.xAxisCanvasContainer.height());
      }
      if (this.yAxis.dirty) {
        this.yAxis.render(this.yAxisCanvas, this.yFormatter, this.yAxisCanvasContainer.width(), this.yAxisCanvasContainer.height());
      }
      if (this.context) {
        this.context.clear();
        if (this.opts.grid && this.opts.grid.indexOf('x') >= 0) {
          this.xAxis.renderGrid(this.dataCanvas, this.context.width, this.context.height);
        }
        if (this.opts.grid && this.opts.grid.indexOf('y') >= 0) {
          this.yAxis.renderGrid(this.dataCanvas, this.context.width, this.context.height);
        }
        this.renderData(this.context);
      }
      stopTime = new Date().getTime();
      return console.log("rendered chart in " + (stopTime - startTime) + "ms");
    };

    return Chart;

  })();

}).call(this);

/*
//@ sourceMappingURL=chart.map
*/
;// Generated by CoffeeScript 1.6.3
(function() {
  var smartCeil,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  smartCeil = function(v) {
    var divisor, log, n;
    log = Math.log10(v);
    divisor = Math.pow(10, Math.ceil(log) - 1);
    n = v / divisor;
    while (n > 10) {
      divisor *= 2;
      n = v / divisor;
    }
    return Math.ceil(v / divisor) * divisor;
  };

  this.StackedBarChart = (function(_super) {
    __extends(StackedBarChart, _super);

    function StackedBarChart(container, data, opts) {
      var box, color, column, columnWidth, group, groups, height, opacity, self, sum, totalString, value, values, xGroup, xGroups, xUniq, xValues, y, yMax, _fn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      _.defaults(opts, {
        xField: 'x',
        yField: 'y',
        groupField: 'group',
        opacityField: null,
        xLabel: 'x',
        yLabel: 'y',
        yPrefix: '',
        title: 'Title',
        title_class: null,
        useDataCanvas: false,
        interact: false,
        onClick: function(value) {
          return {};
        }
      });
      StackedBarChart.__super__.constructor.call(this, container, opts);
      this.container.addClass('stacked-bar');
      if (this.opts.yPrefix === '$') {
        this.yFormatter = new DollarFormatter();
      }
      xValues = _.pluck(data, opts.xField);
      xUniq = _.uniq(xValues);
      if (!opts.xOrder) {
        opts.xOrder = xUniq.sort();
      }
      columnWidth = 100 / opts.xOrder.length;
      groups = _.uniq(_.pluck(data, opts.groupField));
      if (!opts.groupOrder) {
        opts.groupOrder = groups.sort();
      }
      this.xAxis.setFixedArray(opts.xOrder);
      yMax = 0;
      xGroups = {};
      _ref = opts.xOrder;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        xGroup = _ref[_i];
        values = _.filter(data, function(v) {
          return v[opts.xField] === xGroup;
        });
        sum = _.reduce(values, function(memo, v) {
          return memo + v[opts.yField];
        }, 0);
        yMax = Math.max(yMax, sum);
        xGroups[xGroup] = {
          values: values,
          total: sum
        };
      }
      this.yResize(0, yMax);
      this.yRound();
      yMax = this.yAxis.max;
      self = this;
      _ref1 = opts.xOrder;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        xGroup = _ref1[_j];
        column = $("<div class='column' style='width: " + columnWidth + "%'></div>").appendTo(this.dataCanvasContainer);
        y = 0;
        _ref2 = opts.groupOrder;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          group = _ref2[_k];
          color = opts.groupColors[group];
          values = _.filter(xGroups[xGroup].values, function(v) {
            return v[opts.groupField] === group;
          });
          _fn = function(value) {
            return box.click(function() {
              self.dataCanvasContainer.find('a.box').removeClass('active');
              $(this).addClass('active');
              return opts.onClick(value);
            });
          };
          for (_l = 0, _len3 = values.length; _l < _len3; _l++) {
            value = values[_l];
            height = value[opts.yField] / yMax * 100;
            opacity = 1;
            if (opts.opacityField) {
              opacity = value[opts.opacityField];
            }
            box = $("<a class='box' style='height: " + height + "%; bottom: " + y + "%; background-color: " + color + "; opacity: " + opacity + "'></a>").appendTo(column);
            _fn(value);
            y += height;
          }
        }
        totalString = this.yFormatter.format(this.yAxis.span, xGroups[xGroup].total);
        $("<div class='total' style='bottom: " + y + "%'>" + opts.yPrefix + totalString + "</div>").appendTo(column);
      }
      this.render();
    }

    return StackedBarChart;

  })(Chart);

  window.tinyplot.StackedBarChart = StackedBarChart;

}).call(this);

/*
//@ sourceMappingURL=bar.map
*/
;// Generated by CoffeeScript 1.6.3
(function() {
  var getIndex,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  getIndex = function(values, value) {
    var iMax, iMid, iMin, vMax, vMid, vMin;
    iMin = 0;
    iMax = values.length - 1;
    vMin = values[iMin];
    vMax = values[iMax];
    if (value <= vMin) {
      return 0;
    }
    if (value >= vMax) {
      return values.length - 1;
    }
    while (iMax - iMin > 1) {
      iMid = Math.round((iMin + iMax) / 2);
      vMid = values[iMid];
      if (vMid > value) {
        iMax = iMid;
        vMax = vMid;
      } else {
        iMin = iMid;
        vMin = vMid;
      }
    }
    if ((value - vMin) > (vMax - value)) {
      return iMax;
    } else {
      return iMin;
    }
  };

  this.TimeseriesChart = (function(_super) {
    __extends(TimeseriesChart, _super);

    function TimeseriesChart(container, data, opts) {
      var s, tMax, tMin, y, yMax, yMin, ys, _i, _j, _len, _len1, _ref;
      _.defaults(opts, {
        timeField: 'time',
        xLabel: 'Time',
        xZoom: 'user',
        yZoom: 'auto',
        cursorColor: '#f00',
        series: [],
        xMaxTicks: 6
      });
      TimeseriesChart.__super__.constructor.call(this, container, opts);
      this.container.addClass('timeseries');
      this.xFormatter = new TimeFormatter();
      this.xAxis.roundingStrategy = 'time';
      this.time = _.pluck(data, this.opts.timeField);
      tMin = this.time[0];
      tMax = this.time[this.time.length - 1];
      this.xResize(tMin, tMax);
      this.xClamp();
      yMin = null;
      yMax = null;
      this.data = data;
      _ref = this.opts.series;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        ys = _.pluck(data, s.yField);
        _.defaults(s, {
          color: '#000',
          width: 1,
          markerSize: 6
        });
        for (_j = 0, _len1 = ys.length; _j < _len1; _j++) {
          y = ys[_j];
          if (!yMin || yMin > y) {
            yMin = y;
          }
          if (!yMax || yMax < y) {
            yMax = y;
          }
        }
      }
      this.yResize(yMin, yMax);
      this.yRound();
      this.cursor = $("<div class='cursor'><div class='bar' style='border-left: 1px solid " + opts.cursorColor + "'></div><div class='info'></div></div>").appendTo(this.dataCanvasContainer);
      this.cursorWidth = this.cursor.width();
      this.render();
    }

    TimeseriesChart.prototype.renderData = function(context) {
      var iMax, iMin, p, plotData, plotTime, s, time, ys, _i, _len, _ref;
      iMin = getIndex(this.time, context.xRange.min);
      if (iMin > 0) {
        iMin -= 1;
      }
      iMax = getIndex(this.time, context.xRange.max);
      if (iMax < this.data.length - 2) {
        iMax += 1;
      }
      plotData = this.data.slice(iMin, +iMax + 1 || 9e9);
      plotTime = _.pluck(plotData, this.opts.timeField);
      _ref = this.opts.series;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        ys = _.pluck(plotData, s.yField);
        context.setStroke(s.color, s.width);
        context.stroke(function() {
          var i, _j, _ref1, _results;
          context.moveTo({
            x: plotTime[0],
            y: ys[0]
          });
          _results = [];
          for (i = _j = 1, _ref1 = plotData.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
            _results.push(context.lineTo({
              x: plotTime[i],
              y: ys[i]
            }));
          }
          return _results;
        });
        if (s.marker && plotData.length < context.width / 4) {
          context.drawMarkers(s.marker, s.markerSize, s.color, plotTime, ys);
        }
      }
      if (this.cursor.is(':visible')) {
        time = parseFloat(this.cursor.data('time'));
        p = {
          x: time,
          y: 0
        };
        context.plotToCanvas(p);
        return this.cursor.css('left', p.x - this.cursorWidth / 2);
      }
    };

    TimeseriesChart.prototype.onClick = function(p) {
      var index, info, pCanvas, s, t, time, value, _i, _len, _ref;
      this.context.canvasToPlot(p);
      index = getIndex(this.time, p.x);
      value = this.data[index];
      time = value[this.opts.timeField];
      pCanvas = {
        x: time,
        y: 0
      };
      this.context.plotToCanvas(pCanvas);
      this.cursor.css('left', pCanvas.x - this.cursorWidth / 2);
      this.cursor.data('time', time);
      info = this.cursor.find('.info');
      info.html('');
      t = this.xFormatter.format(this.xAxis.span, p.x).replace('|', ' ');
      info.append("<div style='color: " + this.opts.cursorColor + "'>" + t + "</div>");
      _ref = this.opts.series;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        info.append("<div style='color: " + s.color + "'>" + s.yField + ": " + value[s.yField] + "</div>");
      }
      return this.cursor.show();
    };

    return TimeseriesChart;

  })(Chart);

  window.tinyplot.TimeseriesChart = TimeseriesChart;

}).call(this);

/*
//@ sourceMappingURL=timeseries.map
*/
