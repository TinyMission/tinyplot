// Generated by CoffeeScript 1.6.3
(function() {
  var Axis, RenderContext, XAxis, YAxis,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Axis = (function() {
    function Axis(canvas, min, max) {
      this.canvas = canvas;
      this.dirty = true;
      this.step = 1;
      this.clampMax = null;
      this.clampMin = null;
      this.resize(min, max);
    }

    Axis.prototype.toString = function() {
      return "" + this.min + " to " + this.max + ", step = " + this.step + " (clamp at " + this.clampMin + " to " + this.clampMax + ")";
    };

    Axis.prototype.makeDirty = function() {
      return this.dirty = true;
    };

    Axis.prototype.resize = function(min, max) {
      var exp, _results;
      this.min = min;
      this.max = max;
      this.span = max - min;
      exp = Math.floor(Math.log10(this.span) - 1);
      this.step = Math.pow(10, exp);
      _results = [];
      while (this.span / this.step > 10) {
        _results.push(this.step *= 2);
      }
      return _results;
    };

    Axis.prototype.zoom = function(factor) {
      var avg, newSpan;
      avg = (this.max + this.min) / 2;
      newSpan = this.span / factor;
      if (this.clampMin && this.clampMax && newSpan > (this.clampMax - this.clampMin)) {
        this.min = this.clampMin;
        this.max = this.clampMax;
        this.span = this.clampMax - this.clampMin;
      } else {
        this.min = avg - newSpan / 2;
        this.max = avg + newSpan / 2;
        this.span = newSpan;
      }
      return this.dirty = true;
    };

    Axis.prototype.pan = function(delta) {
      if (delta < 0) {
        if (!this.clampMax || this.clampMax > this.max) {
          this.max = Math.min(this.clampMax, this.max - delta);
          this.min = this.max - this.span;
        }
      } else {
        if (!this.clampMin || this.clampMin < this.min) {
          this.min = Math.max(this.clampMin, this.min - delta);
          this.max = this.min + this.span;
        }
      }
      return this.dirty = true;
    };

    Axis.prototype.round = function() {
      return this.resize(Math.floor(this.min / this.step) * this.step, Math.ceil(this.max / this.step) * this.step);
    };

    Axis.prototype.clamp = function() {
      this.clampMin = this.min;
      return this.clampMax = this.max;
    };

    Axis.prototype.render = function() {
      return this.dirty = false;
    };

    return Axis;

  })();

  XAxis = (function(_super) {
    __extends(XAxis, _super);

    function XAxis(canvas, min, max) {
      XAxis.__super__.constructor.call(this, canvas, min, max);
    }

    return XAxis;

  })(Axis);

  YAxis = (function(_super) {
    __extends(YAxis, _super);

    function YAxis(canvas, min, max) {
      YAxis.__super__.constructor.call(this, canvas, min, max);
    }

    return YAxis;

  })(Axis);

  RenderContext = (function() {
    function RenderContext(canvas, width, height, xRange, yRange) {
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this.xRange = xRange;
      this.yRange = yRange;
      this.lineTo = __bind(this.lineTo, this);
      this.moveTo = __bind(this.moveTo, this);
      this.plotToCanvas = __bind(this.plotToCanvas, this);
      ({});
    }

    RenderContext.prototype.clear = function() {
      return this.canvas.clearRect(0, 0, this.width, this.height);
    };

    RenderContext.prototype.setStroke = function(style, width) {
      this.canvas.strokeStyle = style;
      return this.canvas.lineWidth = width;
    };

    RenderContext.prototype.stroke = function(cb) {
      this.canvas.beginPath();
      cb();
      return this.canvas.stroke();
    };

    RenderContext.prototype.plotToCanvas = function(p) {
      p.x = (p.x - this.xRange.min) / this.xRange.span * this.width;
      return p.y = (1 - (p.y - this.yRange.min) / this.yRange.span) * this.height;
    };

    RenderContext.prototype.moveTo = function(p) {
      this.plotToCanvas(p);
      return this.canvas.moveTo(p.x, p.y);
    };

    RenderContext.prototype.lineTo = function(p) {
      this.plotToCanvas(p);
      return this.canvas.lineTo(p.x, p.y);
    };

    return RenderContext;

  })();

  this.Chart = (function() {
    function Chart(container, opts) {
      var _this = this;
      this.container = $(container);
      this.container.addClass('tinyplot-chart');
      this.onRender = function(context) {
        return {};
      };
      _.defaults(opts, {
        title: 'Chart Title',
        xZoom: 'none',
        yZoom: 'none'
      });
      this.xZoomType = opts.xZoom;
      this.yZoomType = opts.yZoom;
      this.titleArea = $('<div class="title-area"></div>').appendTo(this.container);
      $("<div class='title text'>" + opts.title + "</div>").appendTo(this.titleArea);
      this.xAxisCanvasElem = $('<canvas class="x-axis"></canvas>').appendTo(this.container);
      this.xAxis = new XAxis(this.xAxisCanvasElem[0].getContext('2d'), 0, 1);
      this.yAxisCanvasElem = $('<canvas class="y-axis"></canvas>').appendTo(this.container);
      this.yAxis = new YAxis(this.yAxisCanvasElem[0].getContext('2d'), 0, 1);
      this.dataCanvasElem = $('<canvas class="data"></canvas>').appendTo(this.container);
      this.dataCanvas = this.dataCanvasElem[0].getContext('2d');
      this.dataCanvasElem[0].width = this.dataCanvasElem.width();
      this.dataCanvasElem[0].height = this.dataCanvasElem.height();
      interact(this.dataCanvasElem[0]).draggable({
        inertia: true,
        onmove: function(evt) {
          return _this.pan(evt.dx, evt.dy);
        }
      });
      this.makeContext();
      this.container.on('mousewheel', function(evt) {
        _this.zoom(1 + evt.deltaY / 1000);
        return evt.preventDefault();
      });
    }

    Chart.prototype.xResize = function(min, max) {
      this.xAxis.resize(min, max);
      console.log("xAxis: " + (this.xAxis.toString()));
      return this.xAxis.makeDirty();
    };

    Chart.prototype.xRound = function() {
      this.xAxis.round();
      return console.log("xAxis: " + (this.xAxis.toString()));
    };

    Chart.prototype.xClamp = function() {
      return this.xAxis.clamp();
    };

    Chart.prototype.yResize = function(min, max) {
      this.yAxis.resize(min, max);
      console.log("yAxis: " + (this.yAxis.toString()));
      return this.yAxis.makeDirty();
    };

    Chart.prototype.yRound = function() {
      this.yAxis.round();
      return console.log("yAxis: " + (this.yAxis.toString()));
    };

    Chart.prototype.yClamp = function() {
      return this.yAxis.clamp();
    };

    Chart.prototype.makeContext = function() {
      return this.context = new RenderContext(this.dataCanvas, this.dataCanvasElem.width(), this.dataCanvasElem.height(), this.xAxis, this.yAxis);
    };

    Chart.prototype.zoom = function(delta) {
      var hasZoomed;
      hasZoomed = false;
      if (this.xZoomType === 'user') {
        this.xAxis.zoom(delta);
        hasZoomed = true;
      }
      if (this.yZoomType === 'user') {
        this.yAxis.zoom(delta);
        hasZoomed = true;
      }
      if (hasZoomed) {
        return this.render();
      }
    };

    Chart.prototype.pan = function(dx, dy) {
      var hasPanned;
      hasPanned = false;
      if (this.xZoomType === 'user') {
        this.xAxis.pan(dx / this.context.width * this.xAxis.span);
        hasPanned = true;
      }
      if (this.yZoomType === 'user') {
        this.yAxis.pan(dy / this.context.height * this.yAxis.span);
        hasPanned = true;
      }
      if (hasPanned) {
        return this.render();
      }
    };

    Chart.prototype.render = function() {
      var startTime, stopTime;
      startTime = new Date().getTime();
      if (this.xAxis.dirty) {
        this.xAxis.render();
      }
      if (this.yAxis.dirty) {
        this.yAxis.render();
      }
      this.context.clear();
      this.onRender(this.context);
      stopTime = new Date().getTime();
      return console.log("rendered chart in " + (stopTime - startTime) + "ms");
    };

    return Chart;

  })();

}).call(this);

/*
//@ sourceMappingURL=chart.map
*/
