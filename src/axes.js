// Generated by CoffeeScript 1.6.3
(function() {
  var Axis, ONE_DAY, ONE_HOUR, ONE_MINUTE,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.NumberFormatter = (function() {
    function NumberFormatter() {}

    NumberFormatter.prototype.format = function(span, value) {
      return value.toString();
    };

    return NumberFormatter;

  })();

  this.TimeFormatter = (function() {
    function TimeFormatter() {}

    TimeFormatter.prototype.format = function(span, value) {
      var formatString, t;
      t = moment(value);
      formatString = span < 10000 ? 'mm:ss.SS' : span < 3600 * 1000 ? 'hh:mm:ss' : span < 3600 * 1000 * 24 * 30 ? 'MM/DD|hh:mm A' : 'YYYY-MM-DD';
      return t.format(formatString);
    };

    return TimeFormatter;

  })();

  ONE_MINUTE = 60000;

  ONE_HOUR = ONE_MINUTE * 60;

  ONE_DAY = ONE_HOUR * 24;

  Axis = (function() {
    function Axis(min, max) {
      this.dirty = true;
      this.step = 1;
      this.clampMax = null;
      this.clampMin = null;
      this.tickSize = 8;
      this.fontSize = 12;
      this.color = '#444';
      this.gridColor = '#ccc';
      this.maxTicks = 10;
      this.label = null;
      this.roundingStrategy = 'base10';
      this.resize(min, max);
    }

    Axis.prototype.toString = function() {
      return "" + this.min + " to " + this.max + ", step = " + this.step + " (clamp at " + this.clampMin + " to " + this.clampMax + ")";
    };

    Axis.prototype.makeDirty = function() {
      return this.dirty = true;
    };

    Axis.prototype.resize = function(min, max) {
      var exp, _results;
      this.min = min;
      this.max = max;
      this.span = max - min;
      switch (this.roundingStrategy) {
        case 'base10':
          exp = Math.floor(Math.log10(this.span) - 1);
          this.step = Math.pow(10, exp);
          break;
        case 'time':
          if (this.span < 1000) {
            this.step = 100;
          } else if (this.span < ONE_MINUTE) {
            this.step = 1000;
          } else if (this.span < ONE_HOUR) {
            this.step = ONE_MINUTE;
          } else if (this.span < ONE_DAY * 3) {
            this.step = ONE_HOUR;
          } else {
            this.step = ONE_DAY;
          }
          break;
        default:
          throw "Invalid roundingStrategy: " + this.roundingStrategy;
      }
      _results = [];
      while (this.span / this.step > this.maxTicks) {
        _results.push(this.step *= 2);
      }
      return _results;
    };

    Axis.prototype.zoom = function(factor) {
      var avg, max, min, newSpan;
      avg = (this.max + this.min) / 2;
      newSpan = this.span / factor;
      if (this.clampMin && this.clampMax && newSpan > (this.clampMax - this.clampMin)) {
        this.min = this.clampMin;
        this.max = this.clampMax;
        this.span = this.clampMax - this.clampMin;
      } else {
        min = avg - newSpan / 2;
        max = avg + newSpan / 2;
        this.resize(min, max);
      }
      return this.dirty = true;
    };

    Axis.prototype.pan = function(delta) {
      if (delta < 0) {
        if (!this.clampMax || this.clampMax > this.max) {
          this.max = Math.min(this.clampMax, this.max - delta);
          this.min = this.max - this.span;
        }
      } else {
        if (!this.clampMin || this.clampMin < this.min) {
          this.min = Math.max(this.clampMin, this.min - delta);
          this.max = this.min + this.span;
        }
      }
      return this.dirty = true;
    };

    Axis.prototype.round = function() {
      return this.resize(Math.floor(this.min / this.step) * this.step, Math.ceil(this.max / this.step) * this.step);
    };

    Axis.prototype.clamp = function() {
      this.clampMin = this.min;
      return this.clampMax = this.max;
    };

    Axis.prototype.render = function(canvas, formatter, width, height) {
      canvas.clearRect(0, 0, width, height);
      return this.dirty = false;
    };

    Axis.prototype.renderGrid = function(canvas, width, height) {
      return {};
    };

    return Axis;

  })();

  this.XAxis = (function(_super) {
    __extends(XAxis, _super);

    function XAxis(canvas, min, max) {
      XAxis.__super__.constructor.call(this, canvas, min, max);
    }

    XAxis.prototype.render = function(canvas, formatter, width, height) {
      var line, lines, scale, text, x, xActual, yActual, _i, _len;
      XAxis.__super__.render.call(this, canvas, formatter, width, height);
      scale = width / this.span;
      x = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        canvas.moveTo(xActual, 0);
        canvas.lineTo(xActual, this.tickSize);
        x += this.step;
      }
      canvas.stroke();
      x = Math.floor(this.min / this.step) * this.step;
      canvas.font = "" + this.fontSize + "px sans-serif";
      canvas.textAlign = 'center';
      canvas.fillStyle = this.color;
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        text = formatter.format(this.span, x);
        lines = text.split('|');
        yActual = this.tickSize + this.fontSize;
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          canvas.fillText(line, xActual, yActual);
          yActual += this.fontSize;
        }
        x += this.step;
      }
      return canvas.fillText(this.label, width / 2, this.tickSize + 3 * this.fontSize + 2);
    };

    XAxis.prototype.renderGrid = function(canvas, width, height) {
      var scale, x, xActual;
      scale = width / this.span;
      x = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.gridColor;
      canvas.beginPath();
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        canvas.moveTo(xActual, 0);
        canvas.lineTo(xActual, height);
        x += this.step;
      }
      return canvas.stroke();
    };

    return XAxis;

  })(Axis);

  this.YAxis = (function(_super) {
    __extends(YAxis, _super);

    function YAxis(canvas, min, max) {
      YAxis.__super__.constructor.call(this, canvas, min, max);
    }

    YAxis.prototype.render = function(canvas, formatter, width, height) {
      var line, lines, scale, text, y, yActual, _i, _len;
      YAxis.__super__.render.call(this, canvas, formatter, width, height);
      scale = height / this.span;
      y = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        if (yActual < 0) {
          yActual = 0.5;
        }
        canvas.moveTo(width - this.tickSize, yActual);
        canvas.lineTo(width, yActual);
        y += this.step;
      }
      canvas.stroke();
      y = Math.floor(this.min / this.step) * this.step;
      canvas.font = "" + this.fontSize + "px sans-serif";
      canvas.textAlign = 'right';
      canvas.fillStyle = this.color;
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        canvas.textBaseline = yActual <= 0 ? 'top' : yActual >= height - 1 ? 'alphabetic' : 'middle';
        text = formatter.format(this.span, y);
        lines = text.split('|');
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          canvas.fillText(line, width - this.tickSize - 3, yActual);
          yActual += this.fontSize;
        }
        y += this.step;
      }
      canvas.textAlign = 'center';
      canvas.translate(this.fontSize, height / 2);
      canvas.rotate(3 * Math.PI / 2);
      return canvas.fillText(this.label, 0, 0);
    };

    YAxis.prototype.renderGrid = function(canvas, width, height) {
      var scale, y, yActual;
      scale = height / this.span;
      y = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.gridColor;
      canvas.beginPath();
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        canvas.moveTo(0, yActual);
        canvas.lineTo(width, yActual);
        y += this.step;
      }
      return canvas.stroke();
    };

    return YAxis;

  })(Axis);

}).call(this);

/*
//@ sourceMappingURL=axes.map
*/
