// Generated by CoffeeScript 1.6.3
(function() {
  var Axis,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Axis = (function() {
    function Axis(min, max) {
      this.dirty = true;
      this.step = 1;
      this.clampMax = null;
      this.clampMin = null;
      this.tickSize = 12;
      this.color = '#444';
      this.resize(min, max);
    }

    Axis.prototype.toString = function() {
      return "" + this.min + " to " + this.max + ", step = " + this.step + " (clamp at " + this.clampMin + " to " + this.clampMax + ")";
    };

    Axis.prototype.makeDirty = function() {
      return this.dirty = true;
    };

    Axis.prototype.resize = function(min, max) {
      var exp, _results;
      this.min = min;
      this.max = max;
      this.span = max - min;
      exp = Math.floor(Math.log10(this.span) - 1);
      this.step = Math.pow(10, exp);
      _results = [];
      while (this.span / this.step > 10) {
        _results.push(this.step *= 2);
      }
      return _results;
    };

    Axis.prototype.zoom = function(factor) {
      var avg, max, min, newSpan;
      avg = (this.max + this.min) / 2;
      newSpan = this.span / factor;
      if (this.clampMin && this.clampMax && newSpan > (this.clampMax - this.clampMin)) {
        this.min = this.clampMin;
        this.max = this.clampMax;
        this.span = this.clampMax - this.clampMin;
      } else {
        min = avg - newSpan / 2;
        max = avg + newSpan / 2;
        this.resize(min, max);
      }
      return this.dirty = true;
    };

    Axis.prototype.pan = function(delta) {
      if (delta < 0) {
        if (!this.clampMax || this.clampMax > this.max) {
          this.max = Math.min(this.clampMax, this.max - delta);
          this.min = this.max - this.span;
        }
      } else {
        if (!this.clampMin || this.clampMin < this.min) {
          this.min = Math.max(this.clampMin, this.min - delta);
          this.max = this.min + this.span;
        }
      }
      return this.dirty = true;
    };

    Axis.prototype.round = function() {
      return this.resize(Math.floor(this.min / this.step) * this.step, Math.ceil(this.max / this.step) * this.step);
    };

    Axis.prototype.clamp = function() {
      this.clampMin = this.min;
      return this.clampMax = this.max;
    };

    Axis.prototype.render = function(canvas, width, height) {
      canvas.clearRect(0, 0, width, height);
      return this.dirty = false;
    };

    return Axis;

  })();

  this.XAxis = (function(_super) {
    __extends(XAxis, _super);

    function XAxis(canvas, min, max) {
      XAxis.__super__.constructor.call(this, canvas, min, max);
    }

    XAxis.prototype.render = function(canvas, width, height) {
      var scale, x, xActual;
      XAxis.__super__.render.call(this, canvas, width, height);
      scale = width / this.span;
      x = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (x <= this.max) {
        xActual = Math.ceil((x - this.min) * scale) - 0.5;
        canvas.moveTo(xActual, 0);
        canvas.lineTo(xActual, this.tickSize);
        x += this.step;
      }
      return canvas.stroke();
    };

    return XAxis;

  })(Axis);

  this.YAxis = (function(_super) {
    __extends(YAxis, _super);

    function YAxis(canvas, min, max) {
      YAxis.__super__.constructor.call(this, canvas, min, max);
    }

    YAxis.prototype.render = function(canvas, width, height) {
      var scale, y, yActual;
      YAxis.__super__.render.call(this, canvas, width, height);
      scale = height / this.span;
      y = Math.floor(this.min / this.step) * this.step;
      canvas.strokeStyle = this.color;
      canvas.beginPath();
      while (y <= this.max) {
        yActual = Math.ceil(height - (y - this.min) * scale) - 0.5;
        canvas.moveTo(width - this.tickSize, yActual);
        canvas.lineTo(width, yActual);
        y += this.step;
      }
      return canvas.stroke();
    };

    return YAxis;

  })(Axis);

}).call(this);

/*
//@ sourceMappingURL=axes.map
*/
